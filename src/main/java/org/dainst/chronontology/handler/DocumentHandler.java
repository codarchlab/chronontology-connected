package org.dainst.chronontology.handler;import com.fasterxml.jackson.databind.JsonNode;import org.apache.commons.lang3.RandomStringUtils;import org.dainst.chronontology.handler.dispatch.Dispatcher;import org.dainst.chronontology.handler.model.Document;import org.dainst.chronontology.handler.model.RightsValidator;import spark.Request;import spark.Response;import java.io.IOException;import static org.dainst.chronontology.Constants.HTTP_BAD_REQUEST;import static org.dainst.chronontology.Constants.HTTP_FORBIDDEN;import static org.dainst.chronontology.util.JsonUtils.json;/** * @author Daniel de Oliveira */public abstract class DocumentHandler implements Handler {    private static final String ID = ":id";    private static final String REPLACED_BY_ID = ":replacedById";    public DocumentHandler(Dispatcher dispatcher, RightsValidator rightsValidator) {        this.dispatcher = dispatcher;        this.rightsValidator= rightsValidator;    }    protected final Dispatcher dispatcher;    protected final RightsValidator rightsValidator;    protected final Document makeDocumentModel(            Request req,            Response res,            boolean createId) {        JsonNode n= json(req.body());        if (n==null) {            res.status(HTTP_BAD_REQUEST);            return null;        }        String resourceId= null;        String resourceType= null;        String pathInfo= req.pathInfo();        if (req.pathInfo().startsWith("/data/")) {            pathInfo= req.pathInfo().substring(5);        }        if (createId) {            resourceId= determineFreeId(req);            resourceType= pathInfo.replaceAll("/","");        } else {            resourceId= pathInfo.replaceFirst("\\/.*\\/","");            resourceType= pathInfo.substring(0,pathInfo.lastIndexOf("/")).replaceAll("/","");        }        Document dm = new Document(                resourceId, resourceType,json(req.body()), req.attribute("user"));        if (!userAccessLevelSufficient(req,dm, RightsValidator.Operation.EDIT)) {            res.status(HTTP_FORBIDDEN);            return null;        }        return dm;    }    protected final boolean userAccessLevelSufficient(Request req, Document dm, RightsValidator.Operation operation) {        if (dm.getDataset()!=null &&                !rightsValidator.hasPermission(req.attribute("user"),                        dm.getDataset(), operation)) {            return false;        }        return true;    }    protected String type(Request req) {        String tmp = req.pathInfo();        if (tmp.startsWith("/data/")) tmp = tmp.substring(6);        if (tmp.startsWith("_")) return "_";        // TODO: Seems quite hacky, refactor?        if (req.params(ID) != null) tmp = tmp.replace(req.params(ID),"");        if (req.params(REPLACED_BY_ID) != null) tmp = tmp.replace("/" + req.params(REPLACED_BY_ID),"");        return tmp;    }    protected String simpleId(Request req) {        return req.params(ID);    }    protected String replacedById(Request req) {        return req.params(REPLACED_BY_ID);    }    private static String generateId() {        return RandomStringUtils.randomAlphanumeric(12);    }    private String determineFreeId(Request req) {        String id;        JsonNode existingDoc= null;        do {            id= generateId();            existingDoc = dispatcher.dispatchGet(req.pathInfo(),id);        } while (existingDoc!=null);        return id;    }    @Override    public abstract Object handle(Request req, Response res) throws IOException;}